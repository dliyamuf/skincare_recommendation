# -*- coding: utf-8 -*-
"""skincare_recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CSRRkGRG6M-5pQVsJOsf-4qHbMwuGQUr

# **Project Overview**
In growing fast of brand skincare in the world, many skincare's consumer often struggles to find similar product based in their preferences. The use of Artificial Intellegence (AI) for cosmetic brands to help consumers find their suitable products become future trends nowadays [(Lin et al., 2022)](https://doi.org/10.3390/electronics11010143). Conten-based filtering of recommender system is one of the most useful techniques to find similarity between products. This system leverages machine learning and natural language processing (NLP) to analyze skincare product descriptions, ratings, and user reviews to generate personalized recommendations [(Vinutha et al, 2024)](https://ieeexplore.ieee.org/document/10626458).


***

# **Business Understanding**
## **Problem Statements**
1. What are best skincare products based on rating given by consumers?
2. How to build content-based recommender system to help users find top 5 skincare product that similar with their preferences?
3. What are the best similarity metrics for comparing skincare products?

## **Goals**
1. Find best skincare product based on rating given by consumers on the website.
2. Get top 5 skincare recommendation products to users.
3. Investigate what best similarity metrics based on their performance metrics.

## **Solution Statements**
1. Use mutlivariate analysis EDA on rating and skincare product (type, name, and brand).
2. Develop content-based recommender system suggests products based on their attributes (type, brand, name, and rating) and recommend top best 5 product according to similarity.
3. Compare two different similarity metrics (cosine similarity and jaccard distance) and find the best based on their performance metrics (MAP, MRR, precision, and recall).

***

# **Data Understanding**
The [dataset](https://www.kaggle.com/datasets/prastyasusanto/indonesia-skincare-from-female-daily-reviews) containing skincare information obtained from femaledaily.com. The data was collected using web scraping with the BeautifulSoup library in Python that has been collected by Prastya Susanto, Rimba Erlangga, and Rama Wijaya and posted on Kaggle.

## **Variables**
- **Type** : type of skincare product.
- **Name** : name of skincare product.
- **Brand** : brand name of skincare product in Indonesia
- **Rating** : rating given by consumers. The range of value is from 1.0 to 5.0.
- **Total Reviewers** : number of consumer that reviewes the product in website.
- **Link** : link to the website.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import label_ranking_average_precision_score

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/BOOTCAMP/advanced machine learning dicoding/skincare.csv')

df

df.info()

"""There are 7432 rows and 6 column contain object(5) and float(1) data types.

**Total Reviewers** dtypes must be an integer.
"""

df['Total Reviewers']=df['Total Reviewers'].str.replace(',', '').astype('int64')
df.info()

"""## **Check Missing Values**"""

df.isnull().sum()

"""There's no missing values.

## **Check Duplicated Data**
"""

df.duplicated().sum()

duplicated = df[df.duplicated(keep=False)]
duplicated

"""There are two duplicated data.

## **Check Outlier**

The only column that might have outlier is **Rating**.
"""

palette = sns.color_palette('flare', n_colors=5)
palette

sns.boxplot(df['Rating'], color=palette[0])
plt.show()

"""There are some outliers with value below 2.5.

## **Exploratory Data Analysis**

### **Univariate Analysis**
"""

(df['Brand'].value_counts())

"""There are 1204 brand name of skincare product. We make histogram plot of top 5 most counts brand name."""

if 'Brand' in df.columns:
    top_brands = df['Brand'].value_counts().head(10)
    plt.figure(figsize=(10, 6))
    sns.barplot(x=top_brands.index, y=top_brands.values, palette=palette)
    plt.xticks(rotation=30)
    plt.title('Top 10 Brand Name based on Counts')
    plt.ylabel('Counts')
    plt.xlabel('Brand')

"""The most counts skincare brand is Innisfree with 134 counts."""

plt.figure(figsize=(10, 6))
sns.countplot(df, x='Type', palette=palette)
plt.xticks(rotation=30)
plt.title('Counts of Skincare Product Type')
plt.show()

"""There are 6 types of skincare product, **moisturizer cream** is the most counts skincare product type.

### **Multivariate Analysis**
"""

#most reviewed skincare type
type_reviews = df.groupby('Type')['Total Reviewers'].sum().reset_index()
type_reviews

plt.figure(figsize=(10, 6))
sns.barplot(x='Type', y='Total Reviewers', data=type_reviews, palette=palette)
plt.xticks(rotation=35)
plt.title('Total Reviewers by Type')
plt.show()

"""The most reviewed skincare type product is **Facial Wash** with more than 140.000 reviewers on the website."""

#most reviewed skincare type
brand_reviews = df.groupby('Brand')['Total Reviewers'].sum().reset_index()
top10_brand_reviews = brand_reviews.sort_values(by='Total Reviewers',ascending=False).head(10) #select top 10 most reviewed

plt.figure(figsize=(10, 6))
sns.barplot(x='Brand', y='Total Reviewers', data=top10_brand_reviews, palette=palette)
plt.xticks(rotation=35)
plt.title('Total Reviewers by Brand')
plt.show()

"""Top 10 the most reviewed skincare brand name is **Garnier, Wardah, Pond's, Hada Labo, Emina, Viva Cosmetics, Azarine Cosmetics, Cosrx, Cetaphil,** and **Skin Aqua**."""

#top rating skincare types
type_rating = df.groupby('Type')['Rating'].mean().reset_index()
#calculate average rating
avg_rate = df['Rating'].mean()
#bar plot
plt.figure(figsize=(10, 6))
ax = sns.barplot(x='Type', y='Rating', data=type_rating, palette=palette)
ax.axhline(avg_rate, color='black', linestyle='--', label='Average Rating')
plt.legend(loc='lower right')
plt.ylabel('Average Rating or each type')
plt.title('Top Skincare Types based on Rating')
plt.xticks(rotation=35)
plt.show()

"""Skincare type with average rating above mean average rating of skincare type product are **Moisturizer Cream, Toner, Facial Wash,** and **Moisturizer Gel**."""

#The most popular brand name and it's average rating

# Get the top 10 most frequent brand names
top_brands = df['Brand'].value_counts().head(10).index

# Create a DataFrame with average ratings for top brands
top_brand_ratings = df[df['Brand'].isin(top_brands)].groupby('Brand')['Rating'].agg(['mean', 'count'])
top_brand_ratings = top_brand_ratings.rename(columns={'mean': 'Average Rating', 'count': 'Number of Ratings'})
top_brand_ratings = top_brand_ratings.sort_values(by='Number of Ratings', ascending=False)  # Sort by average rating
top_brand_ratings = top_brand_ratings.reset_index() # Reset the index

top_brand_ratings

plt.figure(figsize=(10, 6))
ax = sns.barplot(x='Brand', y='Average Rating', data=top_brand_ratings, palette=palette)
ax.axhline(avg_rate, color='black', linestyle='--', label='Average Rating')
plt.legend(loc='lower right')
plt.ylabel('Average Rating of each brand')
plt.title('Popular Brand Name based on Rating')
plt.xticks(rotation=35)
plt.show()

"""Popular brand name with highest average rating is **Missha**.

# **Data Preparation**

## **Handling Duplicated Data**

Based on Data Understanding, there's 2 duplicated data. Drop two duplicated data.
"""

df.drop_duplicates(inplace=True)

df.info()

"""So, there's 7430 rows of data.

## **Handling Outlier**

There's some outlier on **Rating** feature with value below 2.5. Keep it because it might contains low rating skincare brand or type informations.

## **Feature Engineering**
"""

# Combine relevant text columns into a single feature
df["Combined_Features"] = df["Type"] + " " + df["Name"] + " " + df["Brand"]

# Initialize TF-IDF Vectorizer (remove stop words and use unigrams & bigrams)
tfidf = TfidfVectorizer(stop_words="english", ngram_range=(1, 2))
tfidf_matrix = tfidf.fit_transform(df["Combined_Features"])

tfidf_matrix.shape

"""Matrix with shape (7430, 22556) created successfully.

# **Model Development**

## **Cosine Similarity**
"""

# Compute Cosine Similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Check the shape of the similarity matrix
cosine_sim.shape

cosine_sim

"""It has a shape of (7432, 7432), meaning each product is compared with every other product.

Create recommendation function with input parameter **product name** and returs **top 5 most similar skincare products** based on cosine similarity.
"""

product_indices = pd.Series(df.index, index=df["Name"]).drop_duplicates()

def recommend_skincare_cosine(product_name, top_n=5):
    """Given a product name, recommend similar skincare products."""
    if product_name not in product_indices:
        return f"Product '{product_name}' not found in the dataset."
    idx = product_indices[product_name]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1][0] if isinstance(x[1], np.ndarray) else x[1], reverse=True)[1:top_n+1] #sort products based on similarity
    product_recommendations = [df.iloc[i[0]][["Name", "Brand", "Type", "Rating"]] for i in sim_scores]
    return pd.DataFrame(product_recommendations)

# Test the recommender system with first product in dataset
sample_product = df["Name"].iloc[0]  # Sun Protection SPF 30 PA+++
recommend_skincare_cosine(sample_product)

"""The system return 5 most similar products of **Sun Protection SPFF 30 PA+++**. All of products type is **Sunscreen** which has the same type of tested product. Now, test with another product name that didn't given in dataset.

## **Jaccard Distance**
"""

from sklearn.metrics import jaccard_score
# Convert 'Type' and 'Brand' to One-Hot Encoding for Jaccard Distance Calculation
df_ohe = pd.get_dummies(df[["Type", "Brand"]])
def recommend_skincare_jaccard(product_name, top_n=5):
    """Compute Jaccard Similarity for a given product based on one-hot encoded features."""
    if product_name not in product_indices:
        return f"Product '{product_name}' not found."

    idx = product_indices[product_name]
    product_vector = df_ohe.iloc[idx].values
    # Compute Jaccard similarity for all products
    jaccard_scores = df_ohe.apply(lambda x: jaccard_score(product_vector, x.values), axis=1)
    top_indices = jaccard_scores.nlargest(top_n + 1).index[1:]
    recommendations = df.iloc[top_indices][["Name", "Brand", "Type", "Rating"]]

    return recommendations

# Test Jaccard Similarity for the first product in dataset
sample_product = df["Name"].iloc[0]  # Sun Protection SPF 30 PA+++
recommend_skincare_jaccard(sample_product)

"""# **Evaluation**

## **Comparison of top 5 recommendation between Cosine and Jaccard Similarity**
"""

print('Cosine Similarity')
print('==============================================================================')
print(recommend_skincare_cosine(sample_product))
print('//////////////////////////////////////////////////////////////////////////////')
print('Jaccard Distance')
print('==============================================================================')
print(recommend_skincare_jaccard(sample_product))

"""Top 5 recommendation given by cosine and jaccard metrics is similar each other with the same type product (Sunscreen).

## **Comparison performance between Cosine and Jaccard**
"""

# Function to compute Precision@K and Recall@K
def precision_recall_at_k(recommended_indices, true_indices, k):
    recommended_set = set(recommended_indices[:k])
    true_set = set(true_indices)
    intersection = recommended_set & true_set

    precision = len(intersection) / k
    recall = len(intersection) / len(true_set) if len(true_set) > 0 else 0

    return precision, recall

# Function to compute MAP@K and MRR@K
def map_mrr_at_k(recommended_indices, true_indices, k):
    ap_sum = 0
    rr_sum = 0
    num_relevant = 0

    for i, rec in enumerate(recommended_indices[:k]):
        if rec in true_indices:
            num_relevant += 1
            ap_sum += num_relevant / (i + 1)
            if rr_sum == 0:
                rr_sum = 1 / (i + 1)

    map_k = ap_sum / min(len(true_indices), k) if true_indices else 0
    mrr_k = rr_sum

    return map_k, mrr_k

true_indices = [19, 66, 684]  # Assuming these are the ground-truth relevant items
recommended_indices_jaccard = recommend_skincare_jaccard(sample_product).index.tolist()
recommended_indices_cosine = recommend_skincare_cosine(sample_product).index.tolist()
# Compute metrics
precision_k, recall_k = precision_recall_at_k(recommended_indices_jaccard, true_indices, k=5)
precision_k_cos, recall_k_cos = precision_recall_at_k(recommended_indices_cosine, true_indices, k=5)
map_k, mrr_k = map_mrr_at_k(recommended_indices_jaccard, true_indices, k=5)
map_k_cos, mrr_k_cos = map_mrr_at_k(recommended_indices_cosine, true_indices, k=5)
#create dataframe
data = {
    'Metrics': ['Precision@5', 'Recall@5', 'MAP@5', 'MRR@5'],
    'Jaccard': [precision_k, recall_k, map_k, mrr_k],
    'Cosine': [precision_k_cos, recall_k_cos, map_k_cos, mrr_k_cos]
}
df_metrics = pd.DataFrame(data)
df_metrics

"""- Both models has same value for **Precision@5** and **Recall@5**. It means that both models recommend 40% relevant products in the top 5 results and retrieve 67% of all relevant products.
- Based on **MAP@5** score, Jaccard ranks relevant items better than Cosine.
- Based on **MRR@5** score, Jaccard finds the first relevant item faster than Cosine.

# **Conclusion**

- Best skincare product type based on mean average rating are **Moisturizer Cream, Toner, Facial Wash,** and **Moisturizer Gel** and best popular model based on average rating is **Missha** with 63 number of ratings and 4.439 average rating.
- Build content-based filtering recommender system with cosine similarity and jaccard distance to find similarities between product names.
- Jaccard Similarity is the better model because it ranks relevant items higher and retrieves relevant products more effectively.
"""